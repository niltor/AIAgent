using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Perigon.Web.SourceGeneration;

[Generator(LanguageNames.CSharp)]
public class LocalizerConstGen : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var resxFiles = context.AdditionalTextsProvider.Where(file =>
            file.Path.EndsWith(".resx", StringComparison.OrdinalIgnoreCase)
        );

        var compilationAndResx = context.CompilationProvider.Combine(resxFiles.Collect());
        context.RegisterSourceOutput(
            compilationAndResx,
            (spc, pair) =>
            {
                var (compilation, resxList) = (pair.Left, pair.Right);

                if (resxList.Length == 0)
                {
                    return;
                }
                var allKeys = new HashSet<string>();
                var fileName = string.Empty;
                foreach (var file in resxList)
                {
                    fileName = Path.GetFileName(file.Path);
                    var text = file.GetText()?.ToString();
                    if (string.IsNullOrWhiteSpace(text))
                    {
                        continue;
                    }

                    // 解析 .resx，提取 keys
                    var doc = XDocument.Parse(text);
                    var keys = doc.Descendants("data")
                        .Select(e => e.Attribute("name")?.Value)
                        .Where(n => !string.IsNullOrWhiteSpace(n))
                        .Distinct();
                    foreach (var key in keys)
                    {
                        allKeys.Add(key!);
                    }
                    break;
                }

                if (allKeys.Count == 0)
                {
                    return;
                }
                var className = fileName.Split('.').FirstOrDefault() ?? "Localizer";
                // 查找 Localizer 类
                var localizerClass = compilation
                    .SyntaxTrees.SelectMany(tree =>
                        tree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>()
                    )
                    .FirstOrDefault(cls => cls.Identifier.Text == className);

                var ns = GetNamespace(localizerClass);

                // 生成 partial class
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine($"namespace {ns};");
                sb.AppendLine($"public partial class {className}");
                sb.AppendLine("{");
                foreach (var key in allKeys.OrderBy(k => k))
                {
                    var valName = key;
                    if (int.TryParse(valName, out _))
                    {
                        valName = $"_{valName}";
                    }
                    if (valName.Contains('-'))
                    {
                        valName = valName.Replace('-', '_');
                    }
                    sb.AppendLine($"    public const string {valName} = \"{key}\";");
                }
                sb.AppendLine("}");

                spc.AddSource($"{className}.g.cs", sb.ToString());
            }
        );
    }

    private static string GetNamespace(ClassDeclarationSyntax classDecl)
    {
        var ns = classDecl.Parent;
        return ns switch
        {
            BaseNamespaceDeclarationSyntax baseNs => baseNs.Name.ToString(),
            _ => "Share",
        };
    }
}
